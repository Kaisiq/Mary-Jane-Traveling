<!DOCTYPE html>

<html>
  <head>
    <title>S0401: Ръбовете на куб</title>
    <meta charset="utf-8" />

    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />

    <script src="three.min.js"></script>
    <script src="init.js"></script>
    <script src="tween.umd.js"></script>
    <script src="mouse.js"></script>
  </head>

  <body>
    <script>
      init();

      let mesh;

      let sizes = [];
      const center = new THREE.Vector2(25.4858, 42.7339);

      loadDistricts("./export_all.geojson");

      positionsOver = [
        new THREE.Vector3(14, -40, heightOverDistrict), //vidin
        new THREE.Vector3(122, -17, heightOverDistrict),
        new THREE.Vector3(135, 5, heightOverDistrict), //varna
        new THREE.Vector3(85, 5, heightOverDistrict), //vt
        new THREE.Vector3(-10, 25, heightOverDistrict), //vidin
        new THREE.Vector3(25, 15, heightOverDistrict), //vraca
        new THREE.Vector3(70, -3, heightOverDistrict), //gabrovo
        new THREE.Vector3(150, 20, heightOverDistrict), //dobrich
        new THREE.Vector3(75, -40, heightOverDistrict), //kard...
        new THREE.Vector3(-5, -20, heightOverDistrict), //slavi
        new THREE.Vector3(40, 0, heightOverDistrict), //LOVECH
        new THREE.Vector3(10, 13, heightOverDistrict), //bosa
        new THREE.Vector3(35, -25, heightOverDistrict), //pazarjik
        new THREE.Vector3(-5, -15, heightOverDistrict), //pernik
        new THREE.Vector3(44, 12, heightOverDistrict), //pleven
        new THREE.Vector3(55, -23, heightOverDistrict), //plovdiv
        new THREE.Vector3(100, 15, heightOverDistrict), //razgrad
        new THREE.Vector3(90, 20, heightOverDistrict), //rusИ
        new THREE.Vector3(115, 25, heightOverDistrict), //silistra
        new THREE.Vector3(100, -10, heightOverDistrict), //sliven
        new THREE.Vector3(50, -40, heightOverDistrict), //smolqn
        new THREE.Vector3(20, -10, heightOverDistrict), //sf-obl
        new THREE.Vector3(20, -10, heightOverDistrict), //sf
        new THREE.Vector3(75, -20, heightOverDistrict), //stz
        new THREE.Vector3(100, 5, heightOverDistrict), //targovishte
        new THREE.Vector3(85, -35, heightOverDistrict), //haskovo
        new THREE.Vector3(115, 10, heightOverDistrict), //shumne
        new THREE.Vector3(110, -20, heightOverDistrict), //qm_mnogo
      ];

      function loadDistricts(path) {
        fetch(path)
          .then((response) => response.json())
          .then((json) => {
            let texture = new THREE.TextureLoader().load(
              "./images/background.png"
            );

            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(0.0053, 0.01);

            texture.offset.set(1.105, 0.56);

            let mapTextureMaterial = new THREE.MeshBasicMaterial({
              map: texture,
            });

            const scratchMaterial = new THREE.MeshBasicMaterial({
              color: new THREE.Color(0xecc834),
            });

            camera.position.set(
              (center.x - 23) * 30,
              (center.y - 43) * 30 - 40,
              190
            );
            oldCameraCoords.copy(camera.position);
            camera.rotation.x = Math.PI / 10;
            let xCoord, yCoord;
            for (let j = 0; j < 28; j++) {
              tweenHasStarted[j] = false;

              const districtShape = new THREE.Shape();
              let firstDot =
                  (json.features[j].geometry.coordinates[0][0][0] - 23) * 30,
                secondDot =
                  (json.features[j].geometry.coordinates[0][0][1] - 43) * 30;

              districtShape.moveTo(
                (json.features[j].geometry.coordinates[0][0][0] - 23) * 30,
                (json.features[j].geometry.coordinates[0][0][1] - 43) * 30
              );
              for (
                let i = 1;
                i < json.features[j].geometry.coordinates[0].length;
                i++
              ) {
                xCoord =
                  (json.features[j].geometry.coordinates[0][i][0] - 23) * 30;
                yCoord =
                  (json.features[j].geometry.coordinates[0][i][1] - 43) * 30;
                if (xCoord < firstDot) firstDot = xCoord;
                if (yCoord > secondDot) secondDot = yCoord;
                districtShape.lineTo(xCoord, yCoord);
              }

              const geometry = new THREE.ShapeGeometry(districtShape);
              if (scratched.includes(j))
                mesh = new THREE.Mesh(geometry, mapTextureMaterial);
              else mesh = new THREE.Mesh(geometry, scratchMaterial);

              const lineGeometry = new THREE.BufferGeometry();

              lineGeometry.setAttribute(
                "position",
                geometry.getAttribute("position")
              );

              const line = new THREE.Line(
                lineGeometry,
                new THREE.LineBasicMaterial({
                  color: 0x324e4a,
                })
              );
              mesh.add(line);

              let boundingBox = new THREE.Box3();
              mesh.geometry.computeBoundingBox();
              let districtSize = new THREE.Vector3();
              boundingBox
                .copy(mesh.geometry.boundingBox)
                .applyMatrix4(mesh.matrixWorld);
              boundingBox.getSize(districtSize);

              generateDotsForScratch(j,firstDot, secondDot, districtSize,mapTextureMaterial);

              scene.add(mesh);

              districts.push(mesh);

              const box = new THREE.BoxHelper(
                mesh,
                new THREE.Color(Math.random(), Math.random(), Math.random())
              );
              // scene.add(box);
            }
            renderer.setAnimationLoop(frame);

            loadDistrictsTweens();
          });
      }

      const raycaster = new THREE.Raycaster();
      const hoverRaycaster = new THREE.Raycaster();
      const hoverMouse = new THREE.Vector2(0, 0);
      let hoverIntersects = null;

      let geometry3 = new THREE.CircleGeometry(5, 16);
      let material3 = new THREE.MeshBasicMaterial({
        color: "red",
        transparent: true,
        opacity: 0.5,
      });
      circle = new THREE.Mesh(geometry3);

      function animate(t) {
        raycaster.setFromCamera(mouseRaycaster, camera);
        // if(canScratch)
        // {
          
        // }
        intersects = raycaster.intersectObjects(districts);

        if (intersects != null && intersects.length != 0 && !cameraMoving) {
          onHover(intersects);
        }

        for (let i = 0; i < 28; i++) {
          if (
            !intersects.find((intersect) => intersect.object === districts[i])
          ) {
            districts[i].position.z = 0;
            tweenHasStarted[i] = false;
          }
        }

        TWEEN.update();
      }

      function loadDistrictsTweens() {
        for (let i = 0; i < 28; i++) {
          let tweeni = new TWEEN.Tween(districts[i].position)
            .to(
              new THREE.Vector3(
                districts[i].position.x,
                districts[i].position.y,
                3
              ),
              1000
            )
            .easing(TWEEN.Easing.Elastic.Out);
          districtsTweens.push(tweeni);
        }
      }

      function generateDotsForScratch(districtIndex,firstDot, secondDot, districtSize,mapTextureMaterial) {
        dots[districtIndex] = [];
        for (let k = 0; k < 200; k++) {
          const circleShape = new THREE.Shape();

          // Define the geometry of the circle
          const x = (firstDot + Math.random() * districtSize.x) * 0.47,
            y = (secondDot + Math.random() * districtSize.y) * 0.52 - 11;

          circleShape.moveTo(x + radiusScratch, y);
          circleShape.arc(x, y, radiusScratch, startAngle, endAngle, false);

          // Create a geometry from the shape
          const geometry = new THREE.ShapeGeometry(circleShape);
          let dot = new THREE.Mesh(geometry, mapTextureMaterial);
          dot.position.z = 0.01;
          dot.visible = false;
          dots[districtIndex].push(dot);
          scene.add(dot);
        }
      }
    </script>
  </body>
</html>
